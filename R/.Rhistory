# Set initial dummy value for thresh
thresh <- 1
while(thresh >= 10^(-5)){
A <- alpha_old * I + beta_old * xmatsqr
m_N <- beta_old * solve(A) %*% t(xmat) %*% y
eigenvalues <- eigen(beta_old * xmatsqr, only.values = TRUE)
gamma <- sum(unlist(lapply(eigenvalues,function(x) x / (alpha_old + x))[1]))
alpha_new <- as.numeric(gamma / (t(m_N) %*% m_N))
e_one <- y - xmat %*% m_N
beta_new <- as.numeric(1 / ((t(e_one) %*% e_one) / (N - gamma)))
thresh <- abs(alpha_old - alpha_new) + abs(beta_old - beta_new)
alpha_old <- alpha_new
beta_old <- beta_new
}
m_N
alpha_new
beta_new
#eigenvalues
#lambda
#}
while(thresh >= 10^(-5)){
A <- alpha_old * I + beta_old * xmatsqr
m_N <- beta_old * solve(A) %*% t(xmat) %*% y
beta_test <- beta_old
eigenvalues <- eigen(beta_old * xmatsqr, only.values = TRUE)
gamma <- sum(unlist(lapply(eigenvalues,function(x) x / (alpha_old + x))[1]))
alpha_new <- as.numeric(gamma / (t(m_N) %*% m_N))
e_one <- y - xmat %*% m_N
beta_new <- as.numeric(1 / ((t(e_one) %*% e_one) / (N - gamma)))
thresh <- abs(alpha_old - alpha_new) + abs(beta_old - beta_new)
alpha_old <- alpha_new
beta_old <- beta_new
}
beta_test
rm(list=ls())
### Q1 ###
#lm_evmax <- function(y,xmat){
load("C:/Users/Willy/OneDrive/公用/台大/Senior courses/Second semester/Statistical Learning/R/Class/data/hw2/rtb2_train.rdata")
nfeat <- 20
rtb3 = rtb2_train[1:(nfeat+1)]
y <- as.matrix(rtb3[,1])
xmat <- model.matrix(paying_price~., data=rtb3)
N <- nrow(xmat)
lambda <- 0.001 * N
xmatsqr <- t(xmat) %*% xmat
I <- diag(nrow(xmatsqr))
w <- (lambda * I + xmatsqr) %*% t(xmat) %*% y
e_zero <- y - xmat %*% w
beta_init <- as.numeric(N / (t(e_zero) %*% e_zero))
alpha_init <- as.numeric(lambda * beta_init)
alpha_old <- alpha_init
beta_old <- beta_init
# Set initial dummy value for thresh
thresh <- 1
while(thresh >= 10^(-5)){
A <- alpha_old * I + beta_old * xmatsqr
m_N <- beta_old * solve(A) %*% t(xmat) %*% y
beta_test <- beta_old
eigenvalues <- eigen(beta_old * xmatsqr, only.values = TRUE)
gamma <- sum(unlist(lapply(eigenvalues,function(x) x / (alpha_old + x))[1]))
alpha_new <- as.numeric(gamma / (t(m_N) %*% m_N))
e_one <- y - xmat %*% m_N
beta_new <- as.numeric(1 / ((t(e_one) %*% e_one) / (N - gamma)))
thresh <- abs(alpha_old - alpha_new) + abs(beta_old - beta_new)
alpha_old <- alpha_new
beta_old <- beta_new
}
beta_test
#m_N
#alpha_new
#beta_new
#eigenvalues
#lambda
#}
rm(list=ls())
### Q1 ###
#lm_evmax <- function(y,xmat){
load("C:/Users/Willy/OneDrive/公用/台大/Senior courses/Second semester/Statistical Learning/R/Class/data/hw2/rtb2_train.rdata")
nfeat <- 20
rtb3 = rtb2_train[1:(nfeat+1)]
y <- as.matrix(rtb3[,1])
xmat <- model.matrix(paying_price~., data=rtb3)
N <- nrow(xmat)
lambda <- 0.001 * N
xmatsqr <- t(xmat) %*% xmat
I <- diag(nrow(xmatsqr))
w <- (lambda * I + xmatsqr) %*% t(xmat) %*% y
e_zero <- y - xmat %*% w
beta_init <- as.numeric(N / (t(e_zero) %*% e_zero))
alpha_init <- as.numeric(lambda * beta_init)
alpha_old <- alpha_init
beta_old <- beta_init
# Set initial dummy value for thresh
thresh <- 1
while(thresh >= 10^(-5)){
A <- alpha_old * I + beta_old * xmatsqr
mN <- beta_old * solve(A) %*% t(xmat) %*% y
alpha <- alpha_old
beta <- beta_old
eigenvalues <- eigen(beta_old * xmatsqr, only.values = TRUE)
gamma <- sum(unlist(lapply(eigenvalues,function(x) x / (alpha_old + x))[1]))
alpha_new <- as.numeric(gamma / (t(mN) %*% mN))
e_one <- y - xmat %*% mN
beta_new <- as.numeric(1 / ((t(e_one) %*% e_one) / (N - gamma)))
thresh <- abs(alpha_old - alpha_new) + abs(beta_old - beta_new)
alpha_old <- alpha_new
beta_old <- beta_new
}
mN
alpha
beta
#beta_test
#m_N
#alpha_new
#beta_new
#eigenvalues
#lambda
#}
A_inv <- solve(A)
A_inv
print(diag(A_inv))
print(sqrt(diag(A_inv)))
rm(list=ls())
### Q1 ###
#lm_evmax <- function(y,xmat){
load("C:/Users/Willy/OneDrive/公用/台大/Senior courses/Second semester/Statistical Learning/R/Class/data/hw2/rtb2_train.rdata")
nfeat <- 20
rtb3 = rtb2_train[1:(nfeat+1)]
y <- as.matrix(rtb3[,1])
xmat <- model.matrix(paying_price~., data=rtb3)
N <- nrow(xmat)
lambda <- 0.001 * N
xmatsqr <- t(xmat) %*% xmat
I <- diag(nrow(xmatsqr))
w <- (lambda * I + xmatsqr) %*% t(xmat) %*% y
e_zero <- y - xmat %*% w
beta_init <- as.numeric(N / (t(e_zero) %*% e_zero))
alpha_init <- as.numeric(lambda * beta_init)
alpha_old <- alpha_init
beta_old <- beta_init
# Set initial dummy value for thresh
thresh <- 1
while(thresh >= 10^(-5)){
A <- alpha_old * I + beta_old * xmatsqr
mN <- beta_old * solve(A) %*% t(xmat) %*% y
alpha <- alpha_old
beta <- beta_old
eigenvalues <- eigen(beta_old * xmatsqr, only.values = TRUE)
gamma <- sum(unlist(lapply(eigenvalues,function(x) x / (alpha_old + x))[1]))
alpha_new <- as.numeric(gamma / (t(mN) %*% mN))
e_one <- y - xmat %*% mN
beta_new <- as.numeric(1 / ((t(e_one) %*% e_one) / (N - gamma)))
thresh <- abs(alpha_old - alpha_new) + abs(beta_old - beta_new)
alpha_old <- alpha_new
beta_old <- beta_new
}
mNsd <- sqrt(diag(solve(A)))
ret <- list(mN=mN,mNsd=mNsd,alpha=alpha,beta=beta)
ret
#beta_test
#m_N
#alpha_new
#beta_new
#eigenvalues
#lambda
#}
### Q1 ###
lm_evmax <- function(y,xmat){
N <- nrow(xmat)
lambda <- 0.001 * N
xmatsqr <- t(xmat) %*% xmat
I <- diag(nrow(xmatsqr))
w <- (lambda * I + xmatsqr) %*% t(xmat) %*% y
e_zero <- y - xmat %*% w
beta_init <- as.numeric(N / (t(e_zero) %*% e_zero))
alpha_init <- as.numeric(lambda * beta_init)
alpha_old <- alpha_init
beta_old <- beta_init
# Set initial dummy value for thresh
thresh <- 1
while(thresh >= 10^(-5)){
A <- alpha_old * I + beta_old * xmatsqr
mN <- beta_old * solve(A) %*% t(xmat) %*% y
alpha <- alpha_old
beta <- beta_old
eigenvalues <- eigen(beta_old * xmatsqr, only.values = TRUE)
gamma <- sum(unlist(lapply(eigenvalues,function(x) x / (alpha_old + x))[1]))
alpha_new <- as.numeric(gamma / (t(mN) %*% mN))
e_one <- y - xmat %*% mN
beta_new <- as.numeric(1 / ((t(e_one) %*% e_one) / (N - gamma)))
thresh <- abs(alpha_old - alpha_new) + abs(beta_old - beta_new)
alpha_old <- alpha_new
beta_old <- beta_new
}
mNsd <- sqrt(diag(solve(A)))
ret <- list(mN=mN,mNsd=mNsd,alpha=alpha,beta=beta)
return(ret)
}
nfeat=seq(1, length(rtb2_train), by = 50)
rm(list=ls())
### Q1 ###
lm_evmax <- function(y,xmat){
N <- nrow(xmat)
lambda <- 0.001 * N
xmatsqr <- t(xmat) %*% xmat
I <- diag(nrow(xmatsqr))
w <- (lambda * I + xmatsqr) %*% t(xmat) %*% y
e_zero <- y - xmat %*% w
beta_init <- as.numeric(N / (t(e_zero) %*% e_zero))
alpha_init <- as.numeric(lambda * beta_init)
alpha_old <- alpha_init
beta_old <- beta_init
# Set initial dummy value for thresh
thresh <- 1
while(thresh >= 10^(-5)){
A <- alpha_old * I + beta_old * xmatsqr
mN <- beta_old * solve(A) %*% t(xmat) %*% y
alpha <- alpha_old
beta <- beta_old
eigenvalues <- eigen(beta_old * xmatsqr, only.values = TRUE)
gamma <- sum(unlist(lapply(eigenvalues,function(x) x / (alpha_old + x))[1]))
alpha_new <- as.numeric(gamma / (t(mN) %*% mN))
e_one <- y - xmat %*% mN
beta_new <- as.numeric(1 / ((t(e_one) %*% e_one) / (N - gamma)))
thresh <- abs(alpha_old - alpha_new) + abs(beta_old - beta_new)
alpha_old <- alpha_new
beta_old <- beta_new
}
mNsd <- sqrt(diag(solve(A)))
ret <- list(mN=mN,mNsd=mNsd,alpha=alpha,beta=beta)
return(ret)
}
### TESTING ###
load("C:/Users/Willy/OneDrive/公用/台大/Senior courses/Second semester/Statistical Learning/R/Class/data/hw2/rtb2_train.rdata")
nfeat=seq(1, length(rtb2_train), by = 50)
rtb3 = rtb2_train[1:10000,nfeat]
y=as.matrix(rtb3[,1])
xmat = model.matrix(paying_price~., data=rtb3)
lmev1 = lm_evmax(y, xmat)
lvem1
lmev1
dmvnorm(testds1_feature,mu,sigma)[1:50]
dmvnorm <- function (x, mean = rep(0, p), sigma = diag(p), log = FALSE)
{
if (is.vector(x))
x <- matrix(x, ncol = length(x))
p <- ncol(x)
if(!missing(mean)) {
if(!is.null(dim(mean))) dim(mean) <- NULL
if (length(mean) != p)
stop("mean and sigma have non-conforming size")
}
if(!missing(sigma)) {
if (p != ncol(sigma))
stop("x and sigma have non-conforming size")
if (!isSymmetric(sigma, tol = sqrt(.Machine$double.eps),
check.attributes = FALSE))
stop("sigma must be a symmetric matrix")
}
## <faster code contributed by Matteo Fasiolo mf364 at bath.ac.uk
dec <- tryCatch(chol(sigma), error=function(e)e)
if (inherits(dec, "error")) {
## warning("cannot compute chol(sigma)"); return(NaN)
## behave the same as dnorm(): return Inf or 0
x.is.mu <- colSums(t(x) != mean) == 0
logretval <- rep.int(-Inf, nrow(x))
logretval[x.is.mu] <- Inf # and all other f(.) == 0
} else {
tmp <- backsolve(dec, t(x) - mean, transpose = TRUE)
rss <- colSums(tmp ^ 2)
logretval <- - sum(log(diag(dec))) - 0.5 * p * log(2 * pi) - 0.5 * rss
}
names(logretval) <- rownames(x)
if(log) logretval else exp(logretval)
}
rm(list=ls())
load("C:/Users/Willy/OneDrive/公用/台大/Senior courses/Second semester/Statistical Learning/R/Class/data/hw3/phonetrain.rdata")
load("C:/Users/Willy/OneDrive/公用/台大/Senior courses/Second semester/Statistical Learning/R/Class/data/hw3/phonetest1.rdata")
train2 = list()
for(aclass in outclass)
{train2[[aclass]] = traindata[[aclass]][1:500,]}
### Q1a ###
pgm_train<-function(outclass, alldata){
ans <- list()
for(iter in 1:length(outclass)){
mu1 <- apply(train2[[iter]],2,mean)
sigma1 <- cov(train2[[iter]])
prec1 <- solve(sigma1)
detsig_log <- log(det(sigma1))
N1 <- nrow(train2[[iter]])
ans[[iter]] <- list(mu1=mu1, sigma1=sigma1, prec1=prec1, detsig_log=detsig_log, N1=N1)
}
names(ans) <- outclass
return(ans)
}
model1=pgm_train(outclass, train2)
dmvnorm <- function (x, mean = rep(0, p), sigma = diag(p), log = FALSE)
{
if (is.vector(x))
x <- matrix(x, ncol = length(x))
p <- ncol(x)
if(!missing(mean)) {
if(!is.null(dim(mean))) dim(mean) <- NULL
if (length(mean) != p)
stop("mean and sigma have non-conforming size")
}
if(!missing(sigma)) {
if (p != ncol(sigma))
stop("x and sigma have non-conforming size")
if (!isSymmetric(sigma, tol = sqrt(.Machine$double.eps),
check.attributes = FALSE))
stop("sigma must be a symmetric matrix")
}
## <faster code contributed by Matteo Fasiolo mf364 at bath.ac.uk
dec <- tryCatch(chol(sigma), error=function(e)e)
if (inherits(dec, "error")) {
## warning("cannot compute chol(sigma)"); return(NaN)
## behave the same as dnorm(): return Inf or 0
x.is.mu <- colSums(t(x) != mean) == 0
logretval <- rep.int(-Inf, nrow(x))
logretval[x.is.mu] <- Inf # and all other f(.) == 0
} else {
tmp <- backsolve(dec, t(x) - mean, transpose = TRUE)
rss <- colSums(tmp ^ 2)
logretval <- - sum(log(diag(dec))) - 0.5 * p * log(2 * pi) - 0.5 * rss
}
names(logretval) <- rownames(x)
if(log) logretval else exp(logretval)
}
head(testds1_feature)
dmvnorm(testds1_feature,mu,sigma)[1:50]
mu <- model1[[1]]$mu1
sigma <- model1[[1]]$sigma1
dmvnorm(testds1_feature,mu,sigma)[1:50]
head(testds1_feature)
dmvnorm(testds1_feature,mu,sigma)[1]
testrow <- testds1_feature[1]
testrow
str(testds1_feature)
testds1_feature[1:3]
testds1_feature[1:3,]
testrow <- testds1_feature[1,]
testrow
length(model1)
### Q1b ###
#testds1_feature
#for(iter in 1:length(outclass)){
#  mu <- model1[[iter]]$mu1
#  sigma <- model1[[iter]]$sigma1
#}
testrow <- testds1_feature[1,]
min <- 0
ind <- 0
for(iter in 1:length(model1)){
mu <- model1[[iter]]$mu1
sigma <- model1[[iter]]$sigma1
if(dmvnorm(testrow,mu,sigma) < min){
min <- dmvnorm(testrow,mu,sigma)
ind <- iter
}
}
#head(testds1_feature)
#dmvnorm(testds1_feature,mu,sigma)[1:50]
#mu
#sigma
#x
#dmvnorm(x,mu,sigma)
ind
### Q1b ###
#testds1_feature
#for(iter in 1:length(outclass)){
#  mu <- model1[[iter]]$mu1
#  sigma <- model1[[iter]]$sigma1
#}
testrow <- testds1_feature[1,]
min <- 0
ind <- 0
for(iter in 1:length(model1)){
mu <- model1[[iter]]$mu1
sigma <- model1[[iter]]$sigma1
if(dmvnorm(testrow,mu,sigma) > min){
min <- dmvnorm(testrow,mu,sigma)
ind <- iter
}
}
ind
#head(testds1_feature)
#dmvnorm(testds1_feature,mu,sigma)[1:50]
#mu
#sigma
#x
#dmvnorm(x,mu,sigma)
find_ans <- function(row){
min <- 0
ind <- 0
for(iter in 1:length(model1)){
mu <- model1[[iter]]$mu1
sigma <- model1[[iter]]$sigma1
if(dmvnorm(testrow,mu,sigma) > min){
min <- dmvnorm(row,mu,sigma)
ind <- iter
}
}
return(ind)
}
testrows <- testds1_feature[1:50,]
testrows <- testds1_feature[1:50,]
find_ans <- function(row){
min <- 0
ind <- 0
for(iter in 1:length(model1)){
mu <- model1[[iter]]$mu1
sigma <- model1[[iter]]$sigma1
if(dmvnorm(testrow,mu,sigma) > min){
min <- dmvnorm(row,mu,sigma)
ind <- iter
}
}
return(ind)
}
apply(testrow2,1,find_ans)
apply(testrows,1,find_ans)
testrows <- testds1_feature[1:50,]
find_ans <- function(row){
min <- 0
ind <- 0
for(iter in 1:length(model1)){
mu <- model1[[iter]]$mu1
sigma <- model1[[iter]]$sigma1
if(dmvnorm(testrow,mu,sigma) > min){
min <- dmvnorm(row,mu,sigma)
ind <- iter
}
}
min <- 0
ind <- 0
return(ind)
}
apply(testrows,1,find_ans)
find_ans <- function(row){
min <- 0
ind <- 0
for(iter in 1:length(model1)){
mu <- model1[[iter]]$mu1
sigma <- model1[[iter]]$sigma1
if(dmvnorm(testrow,mu,sigma) > min){
min <- dmvnorm(row,mu,sigma)
ind <- iter
}
}
return(ind)
}
apply(testrows,1,find_ans)
testrows
testrows <- testds1_feature[2,]
testrow <- testds1_feature[2,]
testrow <- testds1_feature[1:50,]
find_ans <- function(row){
min <- 0
ind <- 0
for(iter in 1:length(model1)){
mu <- model1[[iter]]$mu1
sigma <- model1[[iter]]$sigma1
if(dmvnorm(row,mu,sigma) > min){
min <- dmvnorm(row,mu,sigma)
ind <- iter
}
}
return(ind)
}
apply(testrows,1,find_ans)
apply(testrow,1,find_ans)
apply(testrow,1,find_ans,use.names=FALSE)
unname(apply(testrow,1,find_ans))
### Q1b ###
find_ans <- function(row){
min <- 0
ind <- 0
for(iter in 1:length(model1)){
mu <- model1[[iter]]$mu1
sigma <- model1[[iter]]$sigma1
if(dmvnorm(row,mu,sigma) > min){
min <- dmvnorm(row,mu,sigma)
ind <- iter
}
}
return(ind)
}
pgm_predict <- function(amodel,testdata){
ans <- unname(apply(testrow,1,find_ans))
return(ans)
}
### Q1b ###
pgm_predict <- function(amodel,testdata){
find_ans <- function(row){
min <- 0
ind <- 0
for(iter in 1:length(amodel)){
mu <- amodel[[iter]]$mu1
sigma <- amodel[[iter]]$sigma1
if(dmvnorm(row,mu,sigma) > min){
min <- dmvnorm(row,mu,sigma)
ind <- iter
}
}
return(ind)
}
ans <- unname(apply(testdata,1,find_ans))
return(ans)
}
pred1=pgm_predict(model1, testds1_feature)
pred1[1:50]
